<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dlw.optimization &#8212; dlw 1.0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="dlw 1.0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">dlw 1.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dlw.optimization</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">tools</span> <span class="k">import</span> <span class="n">_pickle_method</span><span class="p">,</span> <span class="n">_unpickle_method</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">copy_reg</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">copyreg</span> <span class="k">as</span> <span class="nn">copy_reg</span>
<span class="kn">import</span> <span class="nn">types</span>

<span class="n">copy_reg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">_pickle_method</span><span class="p">,</span> <span class="n">_unpickle_method</span><span class="p">)</span>

<div class="viewcode-block" id="GenericAlgorithm"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GenericAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">GenericAlgorithm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Optimization algorithm for the DLW-model. </span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	pop_amount : int</span>
<span class="sd">		number of individuals in the population</span>
<span class="sd">	num_feature : int </span>
<span class="sd">		number of elements in each individual, i.e. number of nodes in tree-model</span>
<span class="sd">	num_generations : int </span>
<span class="sd">		number of generations of the populations to be evaluated</span>
<span class="sd">	bound : float</span>
<span class="sd">		upper bound of mitigation in each node</span>
<span class="sd">	cx_prob : float</span>
<span class="sd">		 probability of mating</span>
<span class="sd">	mut_prob : float</span>
<span class="sd">		probability of mutation.</span>
<span class="sd">	utility : `Utility` object</span>
<span class="sd">		object of utility class</span>
<span class="sd">	fixed_values : ndarray, optional</span>
<span class="sd">		nodes to keep fixed</span>
<span class="sd">	fixed_indicies : ndarray, optional</span>
<span class="sd">		indicies of nodes to keep fixed</span>
<span class="sd">	print_progress : bool, optional</span>
<span class="sd">		if the progress of the evolution should be printed</span>

<span class="sd">	Attributes</span>
<span class="sd">	----------</span>
<span class="sd">	pop_amount : int</span>
<span class="sd">		number of individuals in the population</span>
<span class="sd">	num_feature : int </span>
<span class="sd">		number of elements in each individual, i.e. number of nodes in tree-model</span>
<span class="sd">	num_generations : int </span>
<span class="sd">		number of generations of the populations to be evaluated</span>
<span class="sd">	bound : float</span>
<span class="sd">		upper bound of mitigation in each node</span>
<span class="sd">	cx_prob : float</span>
<span class="sd">		 probability of mating</span>
<span class="sd">	mut_prob : float</span>
<span class="sd">		probability of mutation.</span>
<span class="sd">	u : `Utility` object</span>
<span class="sd">		object of utility class</span>
<span class="sd">	fixed_values : ndarray, optional</span>
<span class="sd">		nodes to keep fixed</span>
<span class="sd">	fixed_indicies : ndarray, optional</span>
<span class="sd">		indicies of nodes to keep fixed</span>
<span class="sd">	print_progress : bool, optional</span>
<span class="sd">		if the progress of the evolution should be printed</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_amount</span><span class="p">,</span> <span class="n">num_generations</span><span class="p">,</span> <span class="n">cx_prob</span><span class="p">,</span> <span class="n">mut_prob</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">num_feature</span><span class="p">,</span> <span class="n">utility</span><span class="p">,</span>
				 <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span> <span class="o">=</span> <span class="n">num_feature</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span> <span class="o">=</span> <span class="n">pop_amount</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_gen</span> <span class="o">=</span> <span class="n">num_generations</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cx_prob</span> <span class="o">=</span> <span class="n">cx_prob</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mut_prob</span> <span class="o">=</span> <span class="n">mut_prob</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">utility</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="o">=</span> <span class="n">fixed_values</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span> <span class="o">=</span> <span class="n">fixed_indicies</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span> <span class="o">=</span> <span class="n">print_progress</span>

	<span class="k">def</span> <span class="nf">_generate_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return 1D-array of random values in the given bound as the initial population.&quot;&quot;&quot;</span>
		<span class="n">pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">([</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">:</span>
				<span class="n">ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
		<span class="k">return</span> <span class="n">pop</span>

	<span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indvidual</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the utility of given individual.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">indvidual</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a 1D-array of selected individuals.</span>
<span class="sd">	    </span>
<span class="sd">	    Parameters</span>
<span class="sd">	    ----------</span>
<span class="sd">	    pop : ndarray </span>
<span class="sd">	    	population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;)</span>
<span class="sd">	    rate : float </span>
<span class="sd">	    	the probability of an individual being selected</span>
<span class="sd">		    </span>
<span class="sd">	    Returns</span>
<span class="sd">	    -------</span>
<span class="sd">	    ndarray </span>
<span class="sd">	    	selected individuals</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">rate</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pop</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span>

	<span class="k">def</span> <span class="nf">_random_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">individuals</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Generate a random index of individuals of size &#39;size&#39;.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		individuals : ndarray or list</span>
<span class="sd">			2D-array of individuals</span>
<span class="sd">		size : int </span>
<span class="sd">			number of indices to generate</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ndarray </span>
<span class="sd">			1D-array of indices</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">inds_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">individuals</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">inds_size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_selection_tournament</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tournsize</span><span class="p">,</span> <span class="n">fitness</span><span class="p">):</span>
	    <span class="sd">&quot;&quot;&quot;Select `k` individuals from the input `individuals` using `k`</span>
<span class="sd">	    tournaments of `tournsize` individuals.</span>
<span class="sd">	    </span>
<span class="sd">	    Parameters</span>
<span class="sd">	    ----------</span>
<span class="sd">	    individuals : ndarray or list</span>
<span class="sd">	    	2D-array of individuals to select from</span>
<span class="sd">	    k : int</span>
<span class="sd">	    	 number of individuals to select</span>
<span class="sd">	    tournsize : int</span>
<span class="sd">	    	number of individuals participating in each tournament</span>
<span class="sd">	   </span>
<span class="sd">	   	Returns</span>
<span class="sd">	   	-------</span>
<span class="sd">	   	ndarray s</span>
<span class="sd">	   		selected individuals</span>
<span class="sd">	    </span>
<span class="sd">	    &quot;&quot;&quot;</span>
	    <span class="n">chosen</span> <span class="o">=</span> <span class="p">[]</span>
	    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
	        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_index</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">tournsize</span><span class="p">)</span>
	        <span class="n">aspirants</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
	        <span class="n">aspirants_fitness</span> <span class="o">=</span> <span class="n">fitness</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
	        <span class="n">chosen_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aspirants_fitness</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">aspirants_fitness</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
	        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chosen_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
	        	<span class="n">chosen_index</span> <span class="o">=</span> <span class="n">chosen_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	        <span class="n">chosen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aspirants</span><span class="p">[</span><span class="n">chosen_index</span><span class="p">])</span>
	    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chosen</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_two_point_cross_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Performs a two-point cross-over of the population.</span>
<span class="sd">	    </span>
<span class="sd">	    Parameters</span>
<span class="sd">	    ----------</span>
<span class="sd">		pop : ndarray </span>
<span class="sd">			population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;)</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">child_group1</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
		<span class="n">child_group2</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">child1</span><span class="p">,</span> <span class="n">child2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">child_group1</span><span class="p">,</span> <span class="n">child_group2</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cx_prob</span><span class="p">:</span>
				<span class="n">cxpoint1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">)</span>
				<span class="n">cxpoint2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">cxpoint2</span> <span class="o">&gt;=</span> <span class="n">cxpoint1</span><span class="p">:</span>
					<span class="n">cxpoint2</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1"># Swap the two cx points</span>
					<span class="n">cxpoint1</span><span class="p">,</span> <span class="n">cxpoint2</span> <span class="o">=</span> <span class="n">cxpoint2</span><span class="p">,</span> <span class="n">cxpoint1</span>
				<span class="n">child1</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">],</span> <span class="n">child2</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">]</span> \
				<span class="o">=</span> <span class="n">child2</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">child1</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="n">child1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
					<span class="n">child2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
	
	<span class="k">def</span> <span class="nf">_uniform_cross_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">ind_prob</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Performs a uniform cross-over of the population.</span>
<span class="sd">	    </span>
<span class="sd">	    Parameters</span>
<span class="sd">	    ----------</span>
<span class="sd">	    pop : ndarray</span>
<span class="sd">	    	population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;)</span>
<span class="sd">	    ind_prob : float</span>
<span class="sd">	    	probability of feature cross-over</span>
<span class="sd">	    </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">child_group1</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
		<span class="n">child_group2</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">child1</span><span class="p">,</span> <span class="n">child2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">child_group1</span><span class="p">,</span> <span class="n">child_group2</span><span class="p">):</span>
			<span class="n">size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">child2</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">ind_prob</span><span class="p">:</span>
					<span class="n">child1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">child2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">child2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">child1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">ind_prob</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Mutates individual&#39;s elements. The individual has a probability of `mut_prob` of </span>
<span class="sd">		beeing selected and every element in this individual has a probability `ind_prob` of beeing </span>
<span class="sd">		mutated. The mutated value is a random number.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		pop : ndarray</span>
<span class="sd">			population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;)</span>
<span class="sd">	    ind_prob : float </span>
<span class="sd">	    	probability of feature mutation </span>
<span class="sd">	    scale : float </span>
<span class="sd">	    	scaling constant of the random generated number for mutation</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">pop_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">mutate_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mut_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mutate_index</span><span class="p">:</span>
			<span class="n">feature_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">feature_index</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
	
	<span class="k">def</span> <span class="nf">_uniform_mutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">ind_prob</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Mutates individual&#39;s elements. The individual has a probability of `mut_prob` of</span>
<span class="sd">		beeing selected and every element in this individual has a probability `ind_prob` of beeing </span>
<span class="sd">		mutated. The mutated value is the current value plus a scaled uniform [-0.5,0.5] random value.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		pop : ndarray</span>
<span class="sd">			population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;)</span>
<span class="sd">	    ind_prob : float </span>
<span class="sd">	    	probability of feature mutation </span>
<span class="sd">	    scale : float </span>
<span class="sd">	    	scaling constant of the random generated number for mutation</span>

<span class="sd">	    &quot;&quot;&quot;</span> 
		<span class="n">pop_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">mutate_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pop_len</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mut_prob</span> <span class="o">*</span> <span class="n">pop_len</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mutate_index</span><span class="p">:</span>
			<span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">)</span> 
			<span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span>
			<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">ind_prob</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">*</span><span class="n">inc</span>
			<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>

	<span class="k">def</span> <span class="nf">_show_evolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fits</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Print statistics of the evolution of the population.&quot;&quot;&quot;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">mean</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
		<span class="n">std</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
		<span class="n">min_val</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
		<span class="n">max_val</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
		<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; Min </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Max </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Avg </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">mean</span><span class="p">))</span>
		<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; Std </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Population Size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
		<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; Best Individual: &quot;</span><span class="p">,</span> <span class="n">pop</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">fits</span><span class="p">)])</span>

	<span class="k">def</span> <span class="nf">_survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_tmp</span><span class="p">,</span> <span class="n">fitness_tmp</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The 80 percent of the individuals with best fitness survives to</span>
<span class="sd">		the next generation.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		pop_tmp : ndarray</span>
<span class="sd">			population</span>
<span class="sd">		fitness_tmp : ndarray</span>
<span class="sd">			fitness values of `pop_temp`</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ndarray </span>
<span class="sd">			individuals that survived</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">index_fits</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">fitness_tmp</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">fitness_tmp</span><span class="p">[</span><span class="n">index_fits</span><span class="p">]</span>
		<span class="n">pop</span> <span class="o">=</span> <span class="n">pop_tmp</span><span class="p">[</span><span class="n">index_fits</span><span class="p">]</span>
		<span class="n">num_survive</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.8</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">)</span> 
		<span class="n">survive_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pop</span><span class="p">[:</span><span class="n">num_survive</span><span class="p">])</span>
		<span class="n">survive_fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fitness</span><span class="p">[:</span><span class="n">num_survive</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">survive_pop</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">survive_fitness</span><span class="p">)</span>

<div class="viewcode-block" id="GenericAlgorithm.run"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GenericAlgorithm.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Start the evolution process.</span>
<span class="sd">		</span>
<span class="sd">		The evolution steps are:</span>
<span class="sd">			1. Select the individuals to perform cross-over and mutation.</span>
<span class="sd">			2. Cross over among the selected candidate.</span>
<span class="sd">			3. Mutate result as offspring.</span>
<span class="sd">			4. Combine the result of offspring and parent together. And selected the top </span>
<span class="sd">			   80 percent of original population amount.</span>
<span class="sd">			5. Random Generate 20 percent of original population amount new individuals </span>
<span class="sd">			   and combine the above new population.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		tuple</span>
<span class="sd">			final population and the fitness for the final population</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------Genetic Evolution Starting----------------&quot;</span><span class="p">)</span>
		<span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_population</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">)</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span> <span class="c1"># how do we know pop[i] belongs to fitness[i]?</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_gen</span><span class="p">):</span>
			<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;-- Generation </span><span class="si">{}</span><span class="s2"> --&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">pop_select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span> <span class="n">rate</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">#pop_select = self._selection_tournament(pop, len(pop), 4, fitness)</span>
			<span class="c1">#self._two_point_cross_over(pop_select)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_uniform_cross_over</span><span class="p">(</span><span class="n">pop_select</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">)</span>
			<span class="c1">#do the check for mutation other here and save the indices</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_uniform_mutation</span><span class="p">(</span><span class="n">pop_select</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">num_gen</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_mutate</span><span class="p">(</span><span class="n">pop_select</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
			
			<span class="n">fitness_select</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop_select</span><span class="p">)</span>
			<span class="n">fitness_select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness_select</span><span class="p">])</span>
			
			<span class="n">pop_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">pop_select</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">fitness_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">fitness_select</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

			<span class="n">pop_survive</span><span class="p">,</span> <span class="n">fitness_survive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_survive</span><span class="p">(</span><span class="n">pop_tmp</span><span class="p">,</span> <span class="n">fitness_tmp</span><span class="p">)</span>

			<span class="c1">#pop_new = np.random.random([self.pop_amount - len(pop_survive), self.num_feature])*self.bound</span>
			<span class="n">pop_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_population</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_survive</span><span class="p">))</span>
			<span class="n">fitness_new</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop_new</span><span class="p">)</span>
			<span class="n">fitness_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness_new</span><span class="p">])</span>

			<span class="n">pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop_survive</span><span class="p">,</span> <span class="n">pop_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitness_survive</span><span class="p">,</span> <span class="n">fitness_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_show_evolution</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>

		<span class="n">fitness</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">pop</span><span class="p">,</span> <span class="n">fitness</span></div></div>



<div class="viewcode-block" id="GradientSearch"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch">[docs]</a><span class="k">class</span> <span class="nc">GradientSearch</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;Gradient search optimization algorithm for the DLW-model.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	utility : `Utility` object</span>
<span class="sd">		object of utility class</span>
<span class="sd">	learning_rate : float</span>
<span class="sd">		starting learning rate of gradient descent</span>
<span class="sd">	var_nums : int</span>
<span class="sd">		number of elements in array to optimize</span>
<span class="sd">	accuracy : float</span>
<span class="sd">		stop value for the gradient descent</span>
<span class="sd">	fixed_values : ndarray, optional</span>
<span class="sd">		nodes to keep fixed</span>
<span class="sd">	fixed_indicies : ndarray, optional</span>
<span class="sd">		indicies of nodes to keep fixed</span>
<span class="sd">	print_progress : bool, optional</span>
<span class="sd">		if the progress of the evolution should be printed</span>
<span class="sd">	scale_alpha : ndarray, optional</span>
<span class="sd">		array to scale the learning rate</span>

<span class="sd">	Attributes</span>
<span class="sd">	----------</span>
<span class="sd">	utility : `Utility` object</span>
<span class="sd">		object of utility class</span>
<span class="sd">	learning_rate : float</span>
<span class="sd">		starting learning rate of gradient descent</span>
<span class="sd">	var_nums : int</span>
<span class="sd">		number of elements in array to optimize</span>
<span class="sd">	accuracy : float</span>
<span class="sd">		stop value for the gradient descent</span>
<span class="sd">	fixed_values : ndarray, optional</span>
<span class="sd">		nodes to keep fixed</span>
<span class="sd">	fixed_indicies : ndarray, optional</span>
<span class="sd">		indicies of nodes to keep fixed</span>
<span class="sd">	print_progress : bool, optional</span>
<span class="sd">		if the progress of the evolution should be printed</span>
<span class="sd">	scale_alpha : ndarray, optional</span>
<span class="sd">		array to scale the learning rate</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">utility</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">var_nums</span><span class="p">,</span> <span class="n">accuracy</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">06</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
				 <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">learning_rate</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">utility</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">var_nums</span> <span class="o">=</span> <span class="n">var_nums</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>  <span class="o">=</span> <span class="n">fixed_values</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span> <span class="o">=</span> <span class="n">fixed_indicies</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span> <span class="o">=</span> <span class="n">print_progress</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span> <span class="o">=</span> <span class="n">scale_alpha</span>
		<span class="k">if</span> <span class="n">scale_alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">var_nums</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">_partial_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Calculate the ith element of the gradient vector.&quot;&quot;&quot;</span>
		<span class="n">m_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">m_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
		<span class="n">minus_utility</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m_copy</span><span class="p">)</span>
		<span class="n">m_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
		<span class="n">plus_utility</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m_copy</span><span class="p">)</span>
		<span class="n">grad</span> <span class="o">=</span> <span class="p">(</span><span class="n">plus_utility</span><span class="o">-</span><span class="n">minus_utility</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">grad</span><span class="p">,</span> <span class="n">i</span>

<div class="viewcode-block" id="GradientSearch.numerical_gradient"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch.numerical_gradient">[docs]</a>	<span class="k">def</span> <span class="nf">numerical_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">08</span><span class="p">,</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Calculate utility gradient numerically.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		m : ndarray or list</span>
<span class="sd">			array of mitigation</span>
<span class="sd">		delta : float, optional</span>
<span class="sd">			change in mitigation </span>
<span class="sd">		fixed_indicies : ndarray or list, optional</span>
<span class="sd">			indicies of gradient that should not be calculated</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		ndarray</span>
<span class="sd">			gradient</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
		<span class="k">if</span> <span class="n">fixed_indicies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">fixed_indicies</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>
		<span class="n">indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)),</span> <span class="n">fixed_indicies</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partial_grad</span><span class="p">,</span> <span class="n">indicies</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
			<span class="n">grad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
		<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
		<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
		<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
		<span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
		<span class="k">return</span> <span class="n">grad</span></div>
	
	<span class="k">def</span> <span class="nf">_dynamic_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_increase</span><span class="p">,</span> <span class="n">grad_increase</span><span class="p">,</span> <span class="n">grad_size</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Dynamic learning rate.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">grad_increase</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grad_size</span><span class="p">)</span>
		<span class="n">cons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_increase</span><span class="p">,</span> <span class="n">grad_increase</span><span class="p">)</span> <span class="o">/</span>  <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">grad_increase</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">cons</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span>

<div class="viewcode-block" id="GradientSearch.gradient_descent"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch.gradient_descent">[docs]</a>	<span class="k">def</span> <span class="nf">gradient_descent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_point</span><span class="p">,</span> <span class="n">return_last</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Gradient descent algorithm. The `initial_point` is updated in the direction</span>
<span class="sd">		where the utility function is increases fastest.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		initial_point : ndarray</span>
<span class="sd">			initial guess of the mitigation</span>
<span class="sd">		return_last : bool, optional</span>
<span class="sd">			if True the function returns the last point, else the point </span>
<span class="sd">				with highest utility</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		tuple</span>
<span class="sd">			(best point, best utility)</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>	
		<span class="n">num_decision_nodes</span> <span class="o">=</span> <span class="n">initial_point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_decision_nodes</span><span class="p">))</span>
		<span class="n">u_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">u_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">initial_point</span><span class="p">)</span>
		<span class="n">x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_point</span>
		<span class="n">prev_grad</span> <span class="o">=</span> <span class="mf">0.0</span>
		
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">):</span>
			<span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numerical_gradient</span><span class="p">(</span><span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alpha</span><span class="p">(</span><span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">grad</span><span class="o">-</span><span class="n">prev_grad</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad</span><span class="p">))</span>

			<span class="n">new_x</span> <span class="o">=</span> <span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad</span><span class="o">*</span><span class="n">learning_rate</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">new_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
			
			<span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">new_x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_x</span>
			<span class="n">u_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>
			<span class="n">prev_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="c1">#if i &gt; 50:</span>
			<span class="c1">#	x_diff = np.abs(x_hist[i+1] - x_hist[i]).sum()</span>
			<span class="c1">#	u_diff = np.abs(u_hist[i+1] - u_hist[i])</span>
			<span class="c1">#	if x_diff &lt; self.accuracy or u_diff &lt; self.accuracy:</span>
			<span class="c1">#		print(&quot;Broke iteration..&quot;)</span>
			<span class="c1">#		break</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-- Interation </span><span class="si">{}</span><span class="s2"> -- </span><span class="se">\n</span><span class="s2"> Current Utility: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
				<span class="nb">print</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
	
		<span class="k">if</span> <span class="n">return_last</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">best_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">u_hist</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">x_hist</span><span class="p">[</span><span class="n">best_index</span><span class="p">],</span> <span class="n">u_hist</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="GradientSearch.run"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_point_list</span><span class="p">,</span> <span class="n">topk</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Initiate the gradient search algorithm. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		initial_point_list : list</span>
<span class="sd">			list of initial points to select from</span>
<span class="sd">		topk : int, optional</span>
<span class="sd">			select and run gradient descent on the `topk` first points of </span>
<span class="sd">			`initial_point_list`</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		tuple</span>
<span class="sd">			best mitigation point and the utility of the best mitigation point</span>

<span class="sd">		Raises</span>
<span class="sd">		------</span>
<span class="sd">		ValueError</span>
<span class="sd">			If `topk` is larger than the length of `initial_point_list`.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------Gradient Search Starting----------------&quot;</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="n">topk</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_point_list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;topk </span><span class="si">{}</span><span class="s2"> &gt; number of initial points </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">topk</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_point_list</span><span class="p">)))</span>

		<span class="n">candidate_points</span> <span class="o">=</span> <span class="n">initial_point_list</span><span class="p">[:</span><span class="n">topk</span><span class="p">]</span>
		<span class="n">mitigations</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">utilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">topk</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">cp</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate_points</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">topk</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
				<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting process </span><span class="si">{}</span><span class="s2"> of Gradient Descent&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">m</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_descent</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
			<span class="n">mitigations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
			<span class="n">utilities</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
		<span class="n">best_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span>
	
		<span class="k">return</span> <span class="n">mitigations</span><span class="p">[</span><span class="n">best_index</span><span class="p">],</span> <span class="n">utilities</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="NodeMaximum"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.NodeMaximum">[docs]</a><span class="k">class</span> <span class="nc">NodeMaximum</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Optimization node wise, keeping the rest of the nodes fixed. Starting from the </span>
<span class="sd">	back of the tree and working back to node 0.</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_min_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">utility</span><span class="p">):</span>
  		<span class="n">m_copy</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
   		<span class="n">m_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
   		<span class="k">return</span> <span class="o">-</span><span class="n">utility</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m_copy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

	<span class="nd">@classmethod</span>
<div class="viewcode-block" id="NodeMaximum.run"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.NodeMaximum.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">utility</span><span class="p">):</span>
		<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">fmin</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Utility before </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utility</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting maximizing node wise..&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
			<span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_min_func</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">utility</span><span class="p">),</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done!&quot;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Utility after </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utility</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">m</span></div></div>








</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">dlw 1.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Oscar Sjogren.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>