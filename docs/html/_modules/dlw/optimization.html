<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dlw.optimization &#8212; code  documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="code  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">code  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dlw.optimization</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<div class="viewcode-block" id="GenericAlgorithm"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GenericAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">GenericAlgorithm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Optimization algorithm for the DLW model. </span>

<span class="sd">	Args:</span>
<span class="sd">		pop_amount (int): Number of individuals in the population.</span>
<span class="sd">		num_feature (int): The number of elements in each individual, i.e. number of nodes in tree-model.</span>
<span class="sd">		num_generations (int): Number of generations of the populations to be evaluated.</span>
<span class="sd">		bound (float): Amount to reduce the </span>
<span class="sd">		cx_prob (float): Probability of mating.</span>
<span class="sd">		mut_prob (float): Probability of mutation.</span>
<span class="sd">		utility (obj &#39;Utility&#39;): Utility object containing the valuation function.</span>
<span class="sd">		constraints (ndarray): 1D-array of size (ind_size)</span>

<span class="sd">	TODO: Create and individual class.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_amount</span><span class="p">,</span> <span class="n">num_generations</span><span class="p">,</span> <span class="n">cx_prob</span><span class="p">,</span> <span class="n">mut_prob</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">num_feature</span><span class="p">,</span> <span class="n">utility</span><span class="p">,</span>
				 <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span> <span class="o">=</span> <span class="n">num_feature</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span> <span class="o">=</span> <span class="n">pop_amount</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">num_gen</span> <span class="o">=</span> <span class="n">num_generations</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cx_prob</span> <span class="o">=</span> <span class="n">cx_prob</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mut_prob</span> <span class="o">=</span> <span class="n">mut_prob</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">utility</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="o">=</span> <span class="n">fixed_values</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span> <span class="o">=</span> <span class="n">fixed_indicies</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span> <span class="o">=</span> <span class="n">print_progress</span>

	<span class="k">def</span> <span class="nf">_generate_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return 1D-array of random value in the given bound as the initial population.</span>
<span class="sd">	    </span>
<span class="sd">	    Returns:</span>
<span class="sd">	    	ndarray: Array of random value in the given bound with the shape of (&#39;pop_amount&#39;, &#39;num_feature&#39;).</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#pop = np.random.random([self.pop_amount, self.num_feature]).cumsum(axis=1)*0.1</span>
		<span class="n">pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">([</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bound</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pop</span><span class="p">:</span>
				<span class="n">ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
		<span class="k">return</span> <span class="n">pop</span>

	<span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indvidual</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the utility of given individual.</span>
<span class="sd">	    </span>
<span class="sd">	    Parameters</span>
<span class="sd">	    	indvidual (ndarray or list): The shape of &#39;pop&#39; define as 1 times of num_feature.</span>
<span class="sd">	   </span>
<span class="sd">	    Returns:</span>
<span class="sd">	    	ndarray: Array with utility at time zero.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">indvidual</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a 1D-array of selected individuals.</span>
<span class="sd">	    </span>
<span class="sd">	    Parameters:</span>
<span class="sd">		    pop (ndarray): Population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;).</span>
<span class="sd">		    rate (float): The probability of an individual can be selected among population</span>
<span class="sd">		    </span>
<span class="sd">	    Returns:</span>
<span class="sd">	    	ndarray: Selected individuals.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">rate</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pop</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span>

	<span class="k">def</span> <span class="nf">_random_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">individuals</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Generate a random index of individuals of size &#39;size&#39;.</span>

<span class="sd">		Args:</span>
<span class="sd">			individuals (ndarray or list): 2D-array of individuals.</span>
<span class="sd">			size (int): The number of indices to generate.</span>
<span class="sd">		</span>
<span class="sd">		Returns:</span>
<span class="sd">			ndarray: 1D-array of indices.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">inds_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">individuals</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">inds_size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_selection_tournament</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tournsize</span><span class="p">,</span> <span class="n">fitness</span><span class="p">):</span>
	    <span class="sd">&quot;&quot;&quot;Select &#39;k&#39; individuals from the input &#39;individuals&#39; using &#39;k&#39;</span>
<span class="sd">	    tournaments of &#39;tournsize&#39; individuals.</span>
<span class="sd">	    </span>
<span class="sd">	    Args:</span>
<span class="sd">	    	individuals (ndarray or list): 2D-array of individuals to select from.</span>
<span class="sd">	    	k (int): The number of individuals to select.</span>
<span class="sd">	    	tournsize (int): The number of individuals participating in each tournament.</span>
<span class="sd">	   </span>
<span class="sd">	   	Returns:</span>
<span class="sd">	   		ndarray: Selected individuals.</span>
<span class="sd">	    </span>
<span class="sd">	    &quot;&quot;&quot;</span>
	    <span class="n">chosen</span> <span class="o">=</span> <span class="p">[]</span>
	    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
	        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_index</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">tournsize</span><span class="p">)</span>
	        <span class="n">aspirants</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
	        <span class="n">aspirants_fitness</span> <span class="o">=</span> <span class="n">fitness</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
	        <span class="n">chosen_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aspirants_fitness</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">aspirants_fitness</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
	        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chosen_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
	        	<span class="n">chosen_index</span> <span class="o">=</span> <span class="n">chosen_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	        <span class="n">chosen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aspirants</span><span class="p">[</span><span class="n">chosen_index</span><span class="p">])</span>
	    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chosen</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_two_point_cross_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Performs a two-point cross-over of the population.</span>
<span class="sd">	    </span>
<span class="sd">	    Args:</span>
<span class="sd">			pop (ndarray): Population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;).</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">child_group1</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
		<span class="n">child_group2</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">child1</span><span class="p">,</span> <span class="n">child2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">child_group1</span><span class="p">,</span> <span class="n">child_group2</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cx_prob</span><span class="p">:</span>
				<span class="n">cxpoint1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">)</span>
				<span class="n">cxpoint2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">cxpoint2</span> <span class="o">&gt;=</span> <span class="n">cxpoint1</span><span class="p">:</span>
					<span class="n">cxpoint2</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1"># Swap the two cx points</span>
					<span class="n">cxpoint1</span><span class="p">,</span> <span class="n">cxpoint2</span> <span class="o">=</span> <span class="n">cxpoint2</span><span class="p">,</span> <span class="n">cxpoint1</span>
				<span class="n">child1</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">],</span> <span class="n">child2</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">]</span> \
				<span class="o">=</span> <span class="n">child2</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">child1</span><span class="p">[</span><span class="n">cxpoint1</span><span class="p">:</span><span class="n">cxpoint2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="n">child1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
					<span class="n">child2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
	
	<span class="k">def</span> <span class="nf">_uniform_cross_over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">ind_prob</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Performs a uniform cross-over of the population.</span>
<span class="sd">	    </span>
<span class="sd">	    Args:</span>
<span class="sd">	    	pop (ndarray): Population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;).</span>
<span class="sd">	    	ind_prob (float): Probability of feature cross-over.</span>
<span class="sd">	    </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">child_group1</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
		<span class="n">child_group2</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">child1</span><span class="p">,</span> <span class="n">child2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">child_group1</span><span class="p">,</span> <span class="n">child_group2</span><span class="p">):</span>
			<span class="n">size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">child2</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">ind_prob</span><span class="p">:</span>
					<span class="n">child1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">child2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">child2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">child1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">ind_prob</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Mutates individual&#39;s elements. The individual has a probability</span>
<span class="sd">		of &#39;self.mut_prob&#39; of beeing selected and every element in this </span>
<span class="sd">		individual has a probability &#39;ind_prob&#39; of beeing mutated. The mutated</span>
<span class="sd">		value is a random number.</span>

<span class="sd">		Args:</span>
<span class="sd">			pop (ndarray): Population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;).</span>
<span class="sd">	    	ind_prob (float): Probability of feature mutation.</span>
<span class="sd">	    	scale (float): The scaling of the random generated number for mutation. </span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">pop_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">mutate_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mut_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mutate_index</span><span class="p">:</span>
			<span class="n">feature_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind_prob</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">feature_index</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">:</span>
					<span class="k">continue</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
	
	<span class="k">def</span> <span class="nf">_uniform_mutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">ind_prob</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Mutates individual&#39;s elements. The individual has a probability</span>
<span class="sd">		of &#39;self.mut_prob&#39; of beeing selected and every element in this </span>
<span class="sd">		individual has a probability &#39;ind_prob&#39; of beeing mutated. The mutated</span>
<span class="sd">		value is the current value plus a scaled uniform [-0.5,0.5] random value.</span>

<span class="sd">		Args:</span>
<span class="sd">			pop (ndarray): Population given by 2D-array with shape (&#39;pop_amount&#39;, &#39;num_feature&#39;).</span>
<span class="sd">	    	ind_prob (float): Probability of feature mutation.</span>
<span class="sd">	    	scale (float): The scaling of the random generated number for mutation.</span>

<span class="sd">	    &quot;&quot;&quot;</span> 
		<span class="n">pop_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">mutate_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pop_len</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mut_prob</span> <span class="o">*</span> <span class="n">pop_len</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mutate_index</span><span class="p">:</span>
			<span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">)</span> 
			<span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_feature</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span>
			<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prob</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">ind_prob</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">*</span><span class="n">inc</span>
			<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">pop</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>

	<span class="k">def</span> <span class="nf">_show_evolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fits</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Print statistics of the evolution of the population.&quot;&quot;&quot;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
		<span class="n">mean</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
		<span class="n">std</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
		<span class="n">min_val</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
		<span class="n">max_val</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
		<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; Min </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Max </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Avg </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">mean</span><span class="p">))</span>
		<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; Std </span><span class="si">{}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> Population Size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
		<span class="c1">#print (&quot; Best Individual: &quot;, pop[np.argmax(fits)])</span>

	<span class="k">def</span> <span class="nf">_survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_tmp</span><span class="p">,</span> <span class="n">fitness_tmp</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">index_fits</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">fitness_tmp</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">fitness_tmp</span><span class="p">[</span><span class="n">index_fits</span><span class="p">]</span>
		<span class="n">pop</span> <span class="o">=</span> <span class="n">pop_tmp</span><span class="p">[</span><span class="n">index_fits</span><span class="p">]</span>
		<span class="n">num_survive</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.8</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">)</span> 
		<span class="n">survive_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pop</span><span class="p">[:</span><span class="n">num_survive</span><span class="p">])</span>
		<span class="n">survive_fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fitness</span><span class="p">[:</span><span class="n">num_survive</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">survive_pop</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">survive_fitness</span><span class="p">)</span>

<div class="viewcode-block" id="GenericAlgorithm.run"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GenericAlgorithm.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Start the evolution process.</span>
<span class="sd">		The evolution steps:</span>
<span class="sd">			1. Select the individuals to perform cross-over and mutation.</span>
<span class="sd">			2. Cross over among the selected candidate.</span>
<span class="sd">			3. Mutate result as offspring.</span>
<span class="sd">			4. Combine the result of offspring and parent together. And selected the top </span>
<span class="sd">			   80 percent of original population amount.</span>
<span class="sd">			5. Random Generate 20 percent of original population amount new individuals </span>
<span class="sd">			   and combine the above new population.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------Genetic Evolution Starting----------------&quot;</span><span class="p">)</span>
		<span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_population</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span><span class="p">)</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span> <span class="c1"># how do we know pop[i] belongs to fitness[i]?</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_gen</span><span class="p">):</span>
			<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;-- Generation </span><span class="si">{}</span><span class="s2"> --&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">pop_select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span> <span class="n">rate</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">#pop_select = self._selection_tournament(pop, len(pop), 4, fitness)</span>
			<span class="c1">#self._two_point_cross_over(pop_select)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_uniform_cross_over</span><span class="p">(</span><span class="n">pop_select</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">)</span>
			<span class="c1">#do the check for mutation other here and save the indices</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_uniform_mutation</span><span class="p">(</span><span class="n">pop_select</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">num_gen</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_mutate</span><span class="p">(</span><span class="n">pop_select</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
			
			<span class="n">fitness_select</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop_select</span><span class="p">)</span>
			<span class="n">fitness_select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness_select</span><span class="p">])</span>
			
			<span class="n">pop_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">pop_select</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">fitness_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">fitness_select</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

			<span class="n">pop_survive</span><span class="p">,</span> <span class="n">fitness_survive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_survive</span><span class="p">(</span><span class="n">pop_tmp</span><span class="p">,</span> <span class="n">fitness_tmp</span><span class="p">)</span>

			<span class="c1">#pop_new = np.random.random([self.pop_amount - len(pop_survive), self.num_feature])*self.bound</span>
			<span class="n">pop_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_population</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_amount</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_survive</span><span class="p">))</span>
			<span class="n">fitness_new</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop_new</span><span class="p">)</span>
			<span class="n">fitness_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness_new</span><span class="p">])</span>

			<span class="n">pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop_survive</span><span class="p">,</span> <span class="n">pop_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitness_survive</span><span class="p">,</span> <span class="n">fitness_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_show_evolution</span><span class="p">(</span><span class="n">fitness</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>

		<span class="n">fitness</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>
		<span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fitness</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">pop</span><span class="p">,</span> <span class="n">fitness</span></div></div>



<div class="viewcode-block" id="GradientSearch"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch">[docs]</a><span class="k">class</span> <span class="nc">GradientSearch</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reference the algorithm in http://cs231n.github.io/neural-networks-3/</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">var_nums</span><span class="p">,</span> <span class="n">utility</span><span class="p">,</span> <span class="n">accuracy</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">06</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
				 <span class="n">step</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">fixed_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">learning_rate</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">utility</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">var_nums</span> <span class="o">=</span> <span class="n">var_nums</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>  <span class="o">=</span> <span class="n">fixed_values</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span> <span class="o">=</span> <span class="n">fixed_indicies</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span> <span class="o">=</span> <span class="n">print_progress</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span> <span class="o">=</span> <span class="n">scale_alpha</span>
		<span class="k">if</span> <span class="n">scale_alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">var_nums</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100000</span>

	<span class="k">def</span> <span class="nf">_initial_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
		<span class="k">return</span> <span class="n">m</span>
	
	<span class="k">def</span> <span class="nf">_dynamic_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_increase</span><span class="p">,</span> <span class="n">grad_increase</span><span class="p">,</span> <span class="n">grad_size</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">grad_increase</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grad_size</span><span class="p">)</span>
		<span class="n">cons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_increase</span><span class="p">,</span> <span class="n">grad_increase</span><span class="p">)</span> <span class="o">/</span>  <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">grad_increase</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">cons</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_alpha</span>

<div class="viewcode-block" id="GradientSearch.gradient_descent"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch.gradient_descent">[docs]</a>	<span class="k">def</span> <span class="nf">gradient_descent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_point</span><span class="p">,</span> <span class="n">return_last</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Annealing the learning rate. Step decay: Reduce the learning rate by some factor every few epochs.</span>
<span class="sd">		Typical values might be reducing the learning rate by a half every 5 epochs,</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>	
		<span class="n">num_decision_nodes</span> <span class="o">=</span> <span class="n">initial_point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_decision_nodes</span><span class="p">))</span>
		<span class="n">u_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">u_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">initial_point</span><span class="p">)</span>
		<span class="n">x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_point</span>
		<span class="n">prev_grad</span> <span class="o">=</span> <span class="mf">0.0</span>
		
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">):</span>
			<span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">numerical_gradient</span><span class="p">(</span><span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fixed_indicies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alpha</span><span class="p">(</span><span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">grad</span><span class="o">-</span><span class="n">prev_grad</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">grad</span><span class="p">))</span>

			<span class="n">new_x</span> <span class="o">=</span> <span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad</span><span class="o">*</span><span class="n">learning_rate</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">new_x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_indicies</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_values</span>
			
			<span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">new_x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_x</span>
			<span class="n">u_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span>
			<span class="n">prev_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="c1">#if i &gt; 50:</span>
			<span class="c1">#	x_diff = np.abs(x_hist[i+1] - x_hist[i]).sum()</span>
			<span class="c1">#	u_diff = np.abs(u_hist[i+1] - u_hist[i])</span>
			<span class="c1">#	if x_diff &lt; self.accuracy or u_diff &lt; self.accuracy:</span>
			<span class="c1">#		print(&quot;Broke iteration..&quot;)</span>
			<span class="c1">#		break</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-- Interation </span><span class="si">{}</span><span class="s2"> -- </span><span class="se">\n</span><span class="s2"> Current Utility: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
				<span class="nb">print</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
	
		<span class="k">if</span> <span class="n">return_last</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">x_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_hist</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">best_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">u_hist</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">x_hist</span><span class="p">[</span><span class="n">best_index</span><span class="p">],</span> <span class="n">u_hist</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="GradientSearch.run"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.GradientSearch.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topk</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">initial_point_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Initiate the gradient search algorithm. </span>

<span class="sd">		Args:</span>
<span class="sd">			m (ndarray or list): 1D numpy array of size (num_decision_nodes).</span>
<span class="sd">			alpha (float): Step size in gradient descent.</span>
<span class="sd">			num_iter (int): Number of iterations to run.</span>

<span class="sd">		Returns:</span>
<span class="sd">			ndarray: The history of parameter vector, 2D numpy array of size (num_iter+1, num_decision_nodes) </span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------Gradient Search Starting----------------&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">initial_point_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need size of the initial point array&quot;</span><span class="p">)</span>
			<span class="n">initial_point_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_values</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">topk</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_point_list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;topk </span><span class="si">{}</span><span class="s2"> &gt; number of initial points </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">topk</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_point_list</span><span class="p">)))</span>

		<span class="n">candidate_points</span> <span class="o">=</span> <span class="n">initial_point_list</span><span class="p">[:</span><span class="n">topk</span><span class="p">]</span>
		<span class="n">mitigations</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">utilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">topk</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">cp</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate_points</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">topk</span><span class="p">)):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
				<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting process </span><span class="si">{}</span><span class="s2"> of Gradient Descent&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">m</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_descent</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
			<span class="n">mitigations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
			<span class="n">utilities</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
		<span class="n">best_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span>
	
		<span class="k">return</span> <span class="n">mitigations</span><span class="p">[</span><span class="n">best_index</span><span class="p">],</span> <span class="n">utilities</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="NodeMaximum"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.NodeMaximum">[docs]</a><span class="k">class</span> <span class="nc">NodeMaximum</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_min_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">utility</span><span class="p">):</span>
  		<span class="n">m_copy</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
   		<span class="n">m_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
   		<span class="k">return</span> <span class="o">-</span><span class="n">utility</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m_copy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

	<span class="nd">@classmethod</span>
<div class="viewcode-block" id="NodeMaximum.run"><a class="viewcode-back" href="../../dlw.html#dlw.optimization.NodeMaximum.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">utility</span><span class="p">):</span>
		<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">fmin</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Utility before </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utility</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting maximizing node wise..&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
			<span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_min_func</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">utility</span><span class="p">),</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done!&quot;</span><span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Utility after </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">utility</span><span class="o">.</span><span class="n">utility</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">m</span></div></div>








</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">code  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>